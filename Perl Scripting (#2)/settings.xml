<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="settings.xml">
    <entry key="node_file" type="xstring" value="settings.xml"/>
    <config key="flow_stack"/>
    <config key="internal_node_subsettings">
        <entry key="memory_policy" type="xstring" value="CacheSmallInMemory"/>
    </config>
    <config key="model">
        <entry key="use_prefPage_exe" type="xboolean" value="true"/>
        <entry key="perl_path" type="xstring" value="C:\Strawberry\perl\bin\perl.exe"/>
        <entry key="per_row_script" type="xstring" value=" # Available scripting variables: %%00010 #  - $ROWID: The ID of the current row %%00010 #  - $ROWCOUNT: The number of rows of the input table %%00010 #  - $ROWINDEX: The index of the current row %%00010 #  - $column which is a hash. The keys are the names of  %%00010 #            the columns in the input table which are  %%00010 #            mapped to the values of the current row. %%00010 #  %%00010 # This example reads the column with name c0 which is  %%00010 # supposed to contain strings. The second line replaces  %%00010 # subsequent white spaces with an underscore. %%00010 use strict;%%00010use warnings;%%00010use Cwd;%%00010use IO::Uncompress::Gunzip qw(gunzip $GunzipError);%%00010%%00010use DBI;%%00010use LWP::Simple;%%00010use XML::Simple;%%00010use Data::Dumper;%%00010require LWP::UserAgent;%%00010use DBI;%%00010%%00010our $workdir = $column{'Location'};%%00010our $host = $column{'mysql host'};%%00010our $port = $column{'mysql port'};%%00010our $databasename = $column{'database'};%%00010our $username = $column{'username'};%%00010our $password = $column{'password'};%%00010our $connect = DBI-&gt;connect(&quot;DBI:mysql:host=$host;port=$port&quot;, &quot;$username&quot;, &quot;$password&quot;) or die $!;%%00010%%00010$workdir =~ s/\\/\//g;%%00010print &quot;Workdir: &quot;.$workdir.&quot;\n&quot;;%%00010chdir($workdir);%%00010%%00010our $uniprotFile;%%00010our $stringLinksFile;%%00010opendir(my $DIR, $workdir)  or die $!;%%00010while (my $file = readdir($DIR)) {%%00010    if ($file =~ /.gz/) {%%00010        if ($file =~ /uniprot/) {%%00010            $uniprotFile = $file;%%00010        } elsif ($file =~ /links/) {%%00010            $stringLinksFile = $file;%%00010        }%%00010    }%%00010}%%00010closedir($DIR);%%00010%%00010uniextract($uniprotFile);%%00010%%00010my $string = &quot;tmp_string_uniid.csv&quot;;%%00010opendir($DIR, $workdir)  or die $!;%%00010while (my $file = readdir($DIR)) {%%00010    if (($file =~ /.ssv/) &amp;&amp; ($file =~ /^tmp_/) &amp;&amp; ($file !~ &quot;_string&quot;)) {%%00010        makeTransferTablesAndDataTables($file);%%00010    } elsif (($file =~ /.ssv/) &amp;&amp; ($file =~ /^tmp_/) &amp;&amp; ($file =~ &quot;_string&quot;)) {%%00010        $string = $file;%%00010    }%%00010}%%00010closedir($DIR);%%00010%%00010makeTransferTablesAndDataTablesString($string);%%00010%%00010createSQL();%%00010%%00010sub uniextract {%%00010    print &quot;Starting Uniprot extract.\n&quot;;%%00010    my $uniprot = $_[0];%%00010%%00010    my $file = new IO::Uncompress::Gunzip $uniprot or die &quot;IO::Uncompress::Gunzip failed: $GunzipError\n&quot;;%%00010%%00010    my $activate = 0;%%00010    my $sequence = 0;%%00010    my $ID;%%00010    my $NAME;%%00010    my $SEQUENCE;%%00010    my $GENE;%%00010    my $REVIEWED;%%00010    my $mainid=0;%%00010%%00010    my $genid = 0;%%00010    my $accid = 0;%%00010%%00010    open my $MAIN, &quot;&gt;MAIN.csv&quot;;%%00010    open my $OUTPUT, &quot;&gt;ACC.csv&quot;;%%00010    open my $GEN, &quot;&gt;GEN.csv&quot;;%%00010    open my $STRING, &quot;&gt;tmp_string_uniid.ssv&quot;;%%00010    open my $GO, &quot;&gt;tmp_go_uniid.ssv&quot;;%%00010    open my $INTERPRO, &quot;&gt;tmp_interpro_uniid.ssv&quot;;%%00010    open my $PFAM, &quot;&gt;tmp_pfam_uniid.ssv&quot;;%%00010    open my $PROSITE, &quot;&gt;tmp_prosite_uniid.ssv&quot;;%%00010%%00010    while (my $line=&lt;$file&gt;) {%%00010        chomp $line;%%00010        if ($line=~/^ID  /) {%%00010            $activate = 1;%%00010            my @split = split(/ /, $line);%%00010            $ID = $split[3];%%00010            if ($line =~ &quot;Reviewed&quot;) {%%00010                $REVIEWED = &quot;swiss&quot;;%%00010            } else {%%00010                $REVIEWED = &quot;trembl&quot;;%%00010            }%%00010            $NAME = &quot;none&quot;;%%00010            $SEQUENCE = &quot;&quot;;%%00010            $mainid++;%%00010        }%%00010        if ($activate) {%%00010            if ($sequence) {%%00010                if ($line!~/^\/\//) {%%00010                    $line =~ s/ //g;%%00010                    $SEQUENCE=$SEQUENCE.&quot;&quot;.$line;%%00010                } else {%%00010                    $sequence = 0;%%00010                }%%00010            }%%00010            %%00010            if ($line =~ /^AC   /) {%%00010                $line =~ s/AC   //g;%%00010                $line =~ s/ //g;%%00010                my @accsplit = split (/\;/, $line);%%00010                foreach my $acc (@accsplit) {%%00010                    $accid++;%%00010                    print $OUTPUT &quot;\&quot;&quot;.$accid.&quot;\&quot;,\&quot;&quot;.$acc.&quot;\&quot;,\&quot;&quot;.$mainid.&quot;\&quot;\n&quot;;%%00010                }%%00010            } elsif ($line =~ /^DR   STRING/) {%%00010                my @split = split(/\; /, $line);%%00010                print $STRING $mainid.&quot;;&quot;.$split[1].&quot;\n&quot;;%%00010            }  elsif ($line =~ /^DR   GO/) {%%00010                my @split = split(/\; /, $line);%%00010                $split[2] =~ s/\'//g;%%00010                print $GO $mainid.&quot;;&quot;.$split[2].&quot;;&quot;.$split[1].&quot;\n&quot;;%%00010            }  elsif ($line =~ /^DR   PROSITE/) {%%00010                my @split = split(/\; /, $line);%%00010                $split[2] =~ s/\'//g;%%00010                print $PROSITE $mainid.&quot;;&quot;.$split[2].&quot;;&quot;.$split[1].&quot;\n&quot;;%%00010            }  elsif ($line =~ /^DR   InterPro/) {%%00010                my @split = split(/\; /, $line);%%00010                chop $split[2];%%00010                $split[2] =~ s/\'//g;%%00010                print $INTERPRO $mainid.&quot;;&quot;.$split[2].&quot;;&quot;.$split[1].&quot;\n&quot;;%%00010            } elsif ($line =~ /^DR   Pfam/) {%%00010                my @split = split(/\; /, $line);%%00010                chop $split[3];%%00010                $split[2] =~ s/\'//g;%%00010                print $PFAM $mainid.&quot;;&quot;.$split[2].&quot;;&quot;.$split[1].&quot;\n&quot;;%%00010            } elsif ($line =~ /^DE   RecName\:/) {%%00010                my @split = split(/Full=/, $line);%%00010                chop $split[1];%%00010                $split[1] =~ s/\{(.*?)$//g;%%00010                $NAME = $split[1];%%00010            } elsif ($line =~/GN   Name\=/) {%%00010                my @split = split(/Name=/, $line);%%00010                $split[1] =~ s/\; Synonyms\=/\, /g;%%00010                $split[1] =~ s/\; ORFNames\=/\, /g;%%00010                $split[1] =~ s/\; OrderedLocusNames\=/\, /g;%%00010                $split[1] =~ s/( )+(\{(.*),$)//g;;%%00010                $split[1] =~ s/(\{(.*)\};)//g;%%00010                chop $split[1];%%00010                @split = split(/\, /, $split[1]);%%00010                foreach (@split) {%%00010                    $genid++;%%00010                    $_ =~ s/( )+\{(.*?)$//g;%%00010                    $_ =~ s/( )+//g;%%00010                    print $GEN &quot;\&quot;&quot;.$genid.&quot;\&quot;,\&quot;&quot;.uc($_).&quot;\&quot;,\&quot;&quot;.$mainid.&quot;\&quot;\n&quot;;%%00010                }%%00010            } elsif ($line =~ /^DE   SubName\:/) {%%00010                if ($NAME eq &quot;none&quot;) {%%00010                    my @split = split(/Full=/, $line);%%00010                    chop $split[1];%%00010                    $split[1] =~ s/( )+\{(.*?)$//g;%%00010                    $NAME = $split[1];%%00010                }%%00010            } elsif ($line =~ /^SQ   SEQUENCE/) {%%00010                $sequence=1;%%00010            }%%00010        }%%00010        if ($line=~/^\/\//) {%%00010            if ($activate) {%%00010                print $MAIN &quot;\&quot;&quot;.$mainid.&quot;\&quot;,\&quot;&quot;.$ID.&quot;\&quot;,\&quot;&quot;.$NAME.&quot;\&quot;,\&quot;&quot;.$REVIEWED.&quot;\&quot;,\&quot;&quot;.$SEQUENCE.&quot;\&quot;\n&quot;;%%00010                $activate=0;%%00010            }%%00010        }%%00010    }%%00010%%00010    close $MAIN;%%00010    close $OUTPUT;%%00010    close $GEN;%%00010    close $STRING;%%00010    close $GO;%%00010    close $INTERPRO;%%00010    close $PFAM;%%00010    close $PROSITE;%%00010%%00010    print &quot;...finished\n\n&quot;;%%00010}%%00010%%00010sub makeTransferTablesAndDataTables {%%00010    my $file = $_[0];%%00010%%00010    if ($file =~ /_go_/) {%%00010        my @go = (&quot;F:&quot;, &quot;C:&quot;, &quot;P:&quot;);%%00010        foreach (@go) {%%00010            filterTransferTablesAndDataTables($file, $_);%%00010        }%%00010    } else {%%00010        filterTransferTablesAndDataTables($file, &quot;&quot;);%%00010    }%%00010}%%00010%%00010sub filterTransferTablesAndDataTables {%%00010    my $file = $_[0];%%00010    my $filter = $_[1];%%00010%%00010    if ($filter) {%%00010        print &quot;Starting to generate the transfer table for: &quot;.$file.&quot; - &quot;.$filter.&quot;\n&quot;;%%00010    } else {%%00010        print &quot;Starting to generate the transfer table for: &quot;.$file.&quot;\n&quot;;%%00010    }%%00010%%00010    my $outputname = $file;%%00010    if ($filter) {%%00010        if ($filter eq &quot;F:&quot;) {%%00010            $outputname = &quot;MF&quot;;%%00010        } elsif ($filter eq &quot;C:&quot;) {%%00010            $outputname = &quot;CC&quot;;%%00010        } elsif ($filter eq &quot;P:&quot;) {%%00010            $outputname = &quot;BP&quot;;%%00010        } else {%%00010            die &quot;Falscher Filter\n&quot;.$filter.&quot;\n&quot;;%%00010        }%%00010    } else {%%00010        $outputname =~ s/_uniid.ssv//g;%%00010        $outputname =~ s/tmp_//g;%%00010    }%%00010%%00010    my %TERMS;%%00010    open my $INPUT, &quot;&lt;&quot;, $file or die $!;%%00010    while (my $line = &lt;$INPUT&gt;) {%%00010        chomp $line;%%00010        my @split = split(/;/, $line);%%00010%%00010        $TERMS{$split[1]} = $split[2];%%00010    }%%00010    close $INPUT;%%00010%%00010    my %transfer;%%00010    my $trnum = 0;%%00010%%00010    open my $DATA, &quot;&gt;&quot;, uc($outputname).&quot;.csv&quot;; %%00010    foreach my $term (sort keys %TERMS) {%%00010        $trnum++;%%00010        $transfer{$term}=$trnum;%%00010%%00010        my $print = $term;%%00010        if ($filter) {%%00010            $print =~ s/^$filter//g;%%00010        }%%00010        %%00010        print $DATA &quot;\&quot;&quot;.$trnum.&quot;\&quot;,\&quot;&quot;.$print.&quot;\&quot;,\&quot;&quot;.$TERMS{$term}.&quot;\&quot;\n&quot;;%%00010    }%%00010    close $DATA;%%00010%%00010    my $id = 0;%%00010    open my $TRANSFER, &quot;&gt;&quot;, &quot;TRANSFER_&quot;.uc($outputname).&quot;.csv&quot;;%%00010    open $INPUT, &quot;&lt;&quot;, $file or die $!;%%00010    while (my $line = &lt;$INPUT&gt;) {%%00010        chomp $line;%%00010        my @split = split(/;/, $line);%%00010        my $count = @split;%%00010%%00010        $id++;%%00010        print $TRANSFER &quot;\&quot;&quot;.$id.&quot;\&quot;,\&quot;&quot;.$split[0].&quot;\&quot;,\&quot;&quot;.$transfer{$split[1]}.&quot;\&quot;\n&quot;;%%00010    }%%00010    close $INPUT;    %%00010    close $TRANSFER;%%00010%%00010    print &quot;...finished\n\n&quot;;%%00010}%%00010%%00010sub makeTransferTablesAndDataTablesString {%%00010    my $file = $_[0];%%00010    my %STRINGID;%%00010    print &quot;Starting to generate the transfer table for: &quot;.$file.&quot;\n&quot;;%%00010%%00010    open my $TMP, &quot;&lt;&quot;, $file or die $!;%%00010    while (my $line = &lt;$TMP&gt;) {%%00010        chomp $line;%%00010        my @split = split(/;/, $line);%%00010%%00010        $STRINGID{$split[1]}=$split[0];%%00010    }%%00010    close $TMP;%%00010%%00010    my @QUERY;%%00010    my $stringlinks = new IO::Uncompress::Gunzip $stringLinksFile or die &quot;IO::Uncompress::Gunzip failed: $GunzipError\n&quot;;%%00010    while (my $line=&lt;$stringlinks&gt;) {%%00010        chomp $line;%%00010        if ($line !~ &quot;protein1&quot;) {%%00010            my @split = split(/ /, $line);%%00010            if ((exists $STRINGID{$split[0]}) &amp;&amp; (exists $STRINGID{$split[1]})) {%%00010                push(@QUERY, $line);%%00010            }%%00010        }%%00010    }%%00010    close $stringlinks;%%00010%%00010    open my $STRING, &quot;&gt;&quot;, &quot;STRING.csv&quot; or die $!;%%00010    foreach my $line (@QUERY) {%%00010        my @split = split(/ /, $line);%%00010        print $STRING &quot;\&quot;&quot;.$STRINGID{$split[0]}.&quot;\&quot;,\&quot;&quot;.$STRINGID{$split[1]}.&quot;\&quot;,\&quot;&quot;.$split[2].&quot;\&quot;,\&quot;&quot;.$split[3].&quot;\&quot;,\&quot;&quot;.$split[4].&quot;\&quot;,\&quot;&quot;.$split[5].&quot;\&quot;,\&quot;&quot;.$split[6].&quot;\&quot;,\&quot;&quot;.$split[7].&quot;\&quot;,\&quot;&quot;.$split[8].&quot;\&quot;,\&quot;&quot;.$split[9].&quot;\&quot;\n&quot;;%%00010    }%%00010    close $STRING;%%00010%%00010    print &quot;...finished\n\n&quot;;%%00010}%%00010%%00010sub createSQL {%%00010    print &quot;Creating SQL queries.\n&quot;;%%00010%%00010    my $lineterminator = &quot;\r\n&quot;;%%00010    if ($^O eq &quot;linux&quot; || $^O eq &quot;darwin&quot;) {%%00010        $lineterminator = &quot;\n&quot;;%%00010    }%%00010    %%00010    chdir($workdir);%%00010    my @sql;%%00010    push (@sql, &quot;DROP DATABASE IF EXISTS &quot;.$databasename.&quot;;&quot;);%%00010    push (@sql, &quot;CREATE DATABASE IF NOT EXISTS &quot;.$databasename.&quot;;&quot;);%%00010    push (@sql, &quot;USE &quot;.$databasename.&quot;;&quot;);%%00010    opendir (my $DIR, $workdir) or die $!;%%00010    while (my $file = readdir($DIR)) {%%00010        if ($file =~ /\.csv/) {%%00010            if (($file =~ &quot;.csv&quot;) &amp;&amp; ($file !~ &quot;tmp_&quot;) &amp;&amp; ($file !~ &quot;download&quot;)) {%%00010                if ($file =~ &quot;SIF_GO&quot;) {%%00010                    $file =~ s/\.csv//g;%%00010                    push (@sql, &quot;DROP TABLE IF EXISTS &quot;.lc($file).&quot;;&quot;);%%00010                    push (@sql, &quot;CREATE TABLE IF NOT EXISTS &quot;.lc($file).&quot; (id MEDIUMINT PRIMARY KEY, term1 VARCHAR(132), type VARCHAR(8), term2 VARCHAR(132), INDEX fsearch (term1, type), INDEX bsearch (term2, type));&quot;);%%00010                    push (@sql, &quot;LOAD DATA INFILE \'&quot;.$workdir.&quot;/&quot;.$file.&quot;.csv\' INTO TABLE &quot;.lc($file).&quot; FIELDS TERMINATED BY \'\,\' OPTIONALLY ENCLOSED BY '\&quot;' LINES TERMINATED BY '&quot;.$lineterminator.&quot;';&quot;);               %%00010                } elsif ($file =~ &quot;TRANSFER_&quot;) {%%00010                    $file =~ s/\.csv//g;%%00010                    push (@sql, &quot;DROP TABLE IF EXISTS &quot;.lc($file).&quot;;&quot;);%%00010                    push (@sql, &quot;CREATE TABLE IF NOT EXISTS &quot;.lc($file).&quot; (id MEDIUMINT PRIMARY KEY, mainid MEDIUMINT, termid SMALLINT (5), INDEX fsearch (mainid, termid), INDEX bsearch (termid, mainid));&quot;);%%00010                    push (@sql, &quot;LOAD DATA INFILE \'&quot;.$workdir.&quot;/&quot;.$file.&quot;.csv\' INTO TABLE &quot;.lc($file).&quot; FIELDS TERMINATED BY \'\,\' OPTIONALLY ENCLOSED BY '\&quot;' LINES TERMINATED BY '&quot;.$lineterminator.&quot;';&quot;);%%00010                } elsif ($file =~ &quot;MAIN&quot;) {%%00010                    $file =~ s/\.csv//g;%%00010                    push (@sql, &quot;DROP TABLE IF EXISTS &quot;.lc($file).&quot;;&quot;);%%00010                    push (@sql, &quot;CREATE TABLE IF NOT EXISTS &quot;.lc($file).&quot; (mainid MEDIUMINT PRIMARY KEY, uniid VARCHAR(16), name TINYTEXT, datatype TINYTEXT, sequence MEDIUMTEXT, INDEX uni (uniid));&quot;);%%00010                    push (@sql, &quot;LOAD DATA INFILE \'&quot;.$workdir.&quot;/&quot;.$file.&quot;.csv\' INTO TABLE &quot;.lc($file).&quot; FIELDS TERMINATED BY \'\,\' OPTIONALLY ENCLOSED BY '\&quot;' LINES TERMINATED BY '&quot;.$lineterminator.&quot;';&quot;);%%00010                } elsif ($file =~ &quot;ACC&quot;) {%%00010                    $file =~ s/\.csv//g;%%00010                    push (@sql, &quot;DROP TABLE IF EXISTS &quot;.lc($file).&quot;;&quot;);%%00010                    push (@sql, &quot;CREATE TABLE IF NOT EXISTS &quot;.lc($file).&quot; (id INT AUTO_INCREMENT PRIMARY KEY, acc VARCHAR(10), mainid MEDIUMINT, INDEX faccsearch (acc, mainid), INDEX baccsearch (mainid, acc));&quot;);%%00010                    push (@sql, &quot;LOAD DATA LOCAL INFILE \'&quot;.$workdir.&quot;/&quot;.$file.&quot;.csv\' INTO TABLE &quot;.lc($file).&quot; FIELDS TERMINATED BY \'\,\' OPTIONALLY ENCLOSED BY '\&quot;' LINES TERMINATED BY '&quot;.$lineterminator.&quot;';&quot;);%%00010                } elsif ($file =~ &quot;GEN&quot;) {%%00010                    $file =~ s/\.csv//g;%%00010                    push (@sql, &quot;DROP TABLE IF EXISTS &quot;.lc($file).&quot;;&quot;);%%00010                    push (@sql, &quot;CREATE TABLE IF NOT EXISTS &quot;.lc($file).&quot; (id INT AUTO_INCREMENT PRIMARY KEY, gen VARCHAR(32), mainid MEDIUMINT, INDEX fgensearch (gen, mainid), INDEX bgensearch (mainid, gen));&quot;);%%00010                    push (@sql, &quot;LOAD DATA INFILE \'&quot;.$workdir.&quot;/&quot;.$file.&quot;.csv\' INTO TABLE &quot;.lc($file).&quot; FIELDS TERMINATED BY \'\,\' OPTIONALLY ENCLOSED BY '\&quot;' LINES TERMINATED BY '&quot;.$lineterminator.&quot;';&quot;);%%00010                } elsif ($file =~ &quot;STRING&quot;) {%%00010                    $file =~ s/\.csv//g;%%00010                    push (@sql, &quot;DROP TABLE IF EXISTS &quot;.lc($file).&quot;;&quot;);%%00010                    push (@sql, &quot;CREATE TABLE IF NOT EXISTS &quot;.lc($file).&quot; (mainid1 MEDIUMINT, mainid2 MEDIUMINT, neighborhood SMALLINT, fusion SMALLINT, cooccurence SMALLINT, coexpression SMALLINT, experimental SMALLINT, data SMALLINT, textmining SMALLINT, combined SMALLINT, PRIMARY KEY (mainid1, mainid2));&quot;);%%00010                    push (@sql, &quot;LOAD DATA INFILE \'&quot;.$workdir.&quot;/&quot;.$file.&quot;.csv\' INTO TABLE &quot;.lc($file).&quot; FIELDS TERMINATED BY \'\,\' OPTIONALLY ENCLOSED BY '\&quot;' LINES TERMINATED BY '&quot;.$lineterminator.&quot;';&quot;);%%00010                } elsif (($file =~ &quot;BP&quot;) || ($file =~ &quot;CC&quot;) || ($file =~ &quot;MF&quot;)) {%%00010                    $file =~ s/\.csv//g;%%00010                    push (@sql, &quot;DROP TABLE IF EXISTS &quot;.lc($file).&quot;;&quot;);%%00010                    push (@sql, &quot;CREATE TABLE IF NOT EXISTS &quot;.lc($file).&quot; (termid SMALLINT (5) PRIMARY KEY, term TINYTEXT, goid TINYTEXT);&quot;);%%00010                    push (@sql, &quot;LOAD DATA INFILE \'&quot;.$workdir.&quot;/&quot;.$file.&quot;.csv\' INTO TABLE &quot;.lc($file).&quot; FIELDS TERMINATED BY \'\,\' OPTIONALLY ENCLOSED BY '\&quot;' LINES TERMINATED BY '&quot;.$lineterminator.&quot;';&quot;);%%00010                } else {%%00010                    $file =~ s/\.csv//g;%%00010                    push (@sql, &quot;DROP TABLE IF EXISTS &quot;.lc($file).&quot;;&quot;);%%00010                    push (@sql, &quot;CREATE TABLE IF NOT EXISTS &quot;.lc($file).&quot; (termid SMALLINT (5) PRIMARY KEY, term TINYTEXT, dbid TINYTEXT);&quot;);%%00010                    push (@sql, &quot;LOAD DATA INFILE \'&quot;.$workdir.&quot;/&quot;.$file.&quot;.csv\' INTO TABLE &quot;.lc($file).&quot; FIELDS TERMINATED BY \'\,\' OPTIONALLY ENCLOSED BY '\&quot;' LINES TERMINATED BY '&quot;.$lineterminator.&quot;';&quot;);%%00010                }%%00010            }%%00010        }%%00010    }%%00010    print &quot;...done.\n\n&quot;;%%00010%%00010    %%00010    print &quot;Writing tables to MYSQL.\n&quot;;%%00010    for my $command (@sql){%%00010        $connect-&gt;do($command);%%00010    }%%00010    print &quot;...done\n&quot;;%%00010}"/>
        <entry key="preface_script" type="xstring" value=""/>
        <entry key="replaced_column" type="xstring" value="new column"/>
        <entry key="append_column" type="xboolean" value="false"/>
        <entry key="return_type" type="xstring" value="java.lang.Double"/>
        <entry key="is_array_return" type="xboolean" value="false"/>
        <entry key="auto_determine_used_columns" type="xboolean" value="true"/>
        <entry key="chunk_size" type="xint" value="100"/>
    </config>
    <config key="nodeAnnotation">
        <entry key="text" type="xstring" value="generate Metadata %%00013%%00010Database"/>
        <entry key="bgcolor" type="xint" value="16777215"/>
        <entry key="x-coordinate" type="xint" value="507"/>
        <entry key="y-coordinate" type="xint" value="359"/>
        <entry key="width" type="xint" value="106"/>
        <entry key="height" type="xint" value="30"/>
        <entry key="alignment" type="xstring" value="CENTER"/>
        <entry key="borderSize" type="xint" value="0"/>
        <entry key="borderColor" type="xint" value="16777215"/>
        <entry key="defFontSize" type="xint" value="9"/>
        <entry key="annotation-version" type="xint" value="20151123"/>
        <config key="styles"/>
    </config>
    <entry key="customDescription" type="xstring" isnull="true" value=""/>
    <entry key="state" type="xstring" value="IDLE"/>
    <entry key="factory" type="xstring" value="org.knime.base.node.perl.PerlNodeFactory"/>
    <entry key="node-name" type="xstring" value="Perl Scripting"/>
    <entry key="node-bundle-name" type="xstring" value="KNIME Perl node"/>
    <entry key="node-bundle-symbolic-name" type="xstring" value="org.knime.ext.perl"/>
    <entry key="node-bundle-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
    <entry key="node-bundle-version" type="xstring" value="4.7.0.v202206271101"/>
    <entry key="node-feature-name" type="xstring" value="KNIME Perl Integration"/>
    <entry key="node-feature-symbolic-name" type="xstring" value="org.knime.features.ext.perl.feature.group"/>
    <entry key="node-feature-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
    <entry key="node-feature-version" type="xstring" value="4.7.0.v202206271101"/>
    <config key="factory_settings"/>
    <entry key="name" type="xstring" value="Perl Scripting"/>
    <entry key="hasContent" type="xboolean" value="false"/>
    <entry key="isInactive" type="xboolean" value="false"/>
    <config key="ports">
        <config key="port_1">
            <entry key="index" type="xint" value="1"/>
            <entry key="port_dir_location" type="xstring" isnull="true" value=""/>
        </config>
    </config>
    <config key="filestores">
        <entry key="file_store_location" type="xstring" isnull="true" value=""/>
        <entry key="file_store_id" type="xstring" isnull="true" value=""/>
    </config>
</config>
